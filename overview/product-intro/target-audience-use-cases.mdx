---
title: "Target Audience & Use Cases"
description: "Identify the ideal users and application scenarios for this integration, such as backend engineers seeking insight into GORM SQL statements, SREs monitoring DB performance, or teams standardizing on OpenTelemetry. Explore practical use-case examples."
---

# Target Audience & Use Cases

## Who Should Use GORM OpenTelemetry Integration?

The GORM OpenTelemetry plugin is designed for professionals and teams who need comprehensive visibility into database operations within GORM-based applications. It empowers you to unlock the full potential of OpenTelemetry observability directly from your data access layer with minimal effort.

### Ideal Users

- **Backend Engineers** seeking to trace, monitor, and troubleshoot SQL interactions generated by GORM without invasive instrumentation.
- **Site Reliability Engineers (SREs) and DevOps Teams** responsible for database performance monitoring and alerting inside distributed systems.
- **Observability Leads and Platform Teams** standardizing on OpenTelemetry to unify tracing, metrics, and logs across services, including databases.
- **Quality Assurance and Performance Teams** analyzing application latency and resource consumption at the database level.

By integrating tracing, metrics, and structured logging into GORM operations, this plugin helps decode the database layer's impact on application performance and user experience.

## Practical Use Cases

### 1. Real-Time SQL Traceability and Diagnostics

Instrumenting GORM with OpenTelemetry lets engineers capture detailed traces of every database interaction. This makes it possible to:

- Identify slow or failed queries.
- Understand query execution flow within distributed traces.
- Diagnose issues quickly during development or production incidents.

Example:

> An engineer notices increased latency in a user-facing API. Thanks to OpenTelemetry traces correlated with GORM SQL spans, they quickly isolate a frequent slow-running SELECT query, enabling timely query optimization.

### 2. Database Performance Monitoring through Metrics

Collecting and exporting database metrics allows SRE teams to monitor connection counts, query rates, and error rates. Using Prometheus alongside this integration enables:

- Visualization of real-time database health and usage.
- Alerts based on query failures or resource exhaustion.
- Capacity planning using historical trends.

Example:

> An SRE configures dashboards in Grafana querying Prometheus metrics exposed via this plugin to monitor SQL connections and average query durations, detecting and addressing connection pool saturation.

### 3. Unified Observability in Microservices Environments

When teams adopt OpenTelemetry across services, incorporating database telemetry creates a full picture of service behavior. It allows:

- Seamless correlation between application logs, traces, and metrics.
- Comprehensive root-cause analysis across service boundaries including the DB layer.
- Consistent tooling and monitoring frameworks.

Example:

> A platform team implementing distributed tracing across microservices includes GORM OpenTelemetry to capture database spans automatically. This yields end-to-end insights from HTTP requests down to SQL statements.

### 4. Structured Logging for Contextual Debugging

Replacing GORM’s default logger with a logrus-based logger integrated with OpenTelemetry means:

- Log messages enriched with trace context.
- Easier log tracing and correlation.
- Improved observability during log analysis.

Example:

> During incident investigation, logs include the trace ID from which the SQL error originated, drastically reducing the mean time to resolution.

## Before-and-After Scenario

| Without GORM OpenTelemetry  | With GORM OpenTelemetry               |
|-----------------------------|-------------------------------------|
| SQL queries are opaque, disconnected from traces or metrics. | Every query has a trace span with metadata, linked to application telemetry.|
| Troubleshooting DB issues requires manual query logging or external profiling.| Automatic capture of errors, latencies, and context with minimal code changes.|
| Metrics are fragmented or missing for database performance.| Metrics exposed and scraped by Prometheus for real-time alerting and dashboards.|

## Key Benefits at a Glance

- **Instant Visibility:** Get immediate insights into your GORM SQL calls and DB status.
- **Time Savings:** Reduce effort and complexity of instrumenting database layers manually.
- **Improved Reliability:** Early detection of performance bottlenecks and errors.
- **Standardization:** Align with OpenTelemetry ecosystem for consistent observability.

## Getting Started

To see this integration in action, explore the [Tracing example](../demo/README.md) and [Metrics example](../metric/README.md).

Launch the provided Docker Compose setups to run Jaeger and Prometheus services that visualize your telemetry data:

```shell
# For tracing with Jaeger
cd examples/demo
docker-compose up -d

# For metrics with Prometheus
cd examples/metric
docker-compose up -d
```

Access:

- Jaeger UI at `http://localhost:16686` to explore trace data.
- Prometheus UI at `http://localhost:9090` to query and graph metrics.
- Grafana at `http://localhost:3000` for advanced dashboards (anonymous admin access).

This setup creates a seamless observability environment for your GORM-powered applications.

---

### Practical Tips & Best Practices

- **Use Environment Variables** to configure exporters (e.g., `OTEL_EXPORTER_JAEGER_ENDPOINT`) for flexible deployment.
- **Leverage context propagation** within your application for distributed tracing continuity.
- **Customize metrics scrape intervals** in Prometheus to balance resolution and system load.
- **Correlate logs with traces** by instrumenting GORM logging via the plugin’s logrus setup.

### Troubleshooting Common Challenges

- Ensure the OpenTelemetry collectors (e.g., Jaeger, Prometheus) are correctly running and accessible.
- Confirm your application context is properly propagated to capture meaningful trace spans.
- Check Docker Compose service ports and environment variables if no telemetry data appears.

---

With GORM OpenTelemetry integration, backend engineers, SREs, and teams gain invaluable insight into the performance and health of their database operations, enabling faster troubleshooting, enhanced observability, and standardized monitoring practices.

---

# Related Documentation

- [What is GORM OpenTelemetry?](/overview/product-intro/what-is-gorm-otel)
- [Core Features at a Glance](/overview/product-intro/core-features)
- [Installing and Configuring OpenTelemetry Features](/getting-started/installation-and-configuration/basic-configuration)
- [Tracing and Metrics Examples](../examples/README.md)
- [Instrumenting GORM Logging with Logrus](/guides/essential-workflows/setup-logging)

# External Resources

- [OpenTelemetry Official Site](https://opentelemetry.io/)
- [Jaeger Tracing](https://www.jaegertracing.io/)
- [Prometheus Monitoring](https://prometheus.io/)
- [Grafana Dashboards](https://grafana.com/)
